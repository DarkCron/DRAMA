|FUNC		FIBON			MAIN
|PARAMS:	N	N	1(R8)		/
|
|LOCALS:		/		G	N	-2(R8)
|
|RESULT:	Y	N	2(R8)		/
|FOR THE RESULT WE CAN'T USE R0 IN (THIS) RECURSIVE FUNCTION, FOR MORE INFO CHECK THE BOOK
|THIS PROGRAM RETURNS THE N'TH FIBONACCI NUMBER, AT A VERY, VERY EXPENSIVE RESURSIVE ALGORITHM, EVERY FIBON
|FUNCTION CALLS ITSELF TWICE, IF N = 20 IT WOULD CALL:
|TWICE FOR FIBON(20)
|FOUR TIMES FOR FIBON(20-1) (TWO TIMES FOR FIBON(N-1) AND FIBON(N-2))
|EIGHT TIMES FOR FIBON(20-2) (TWO TIMES RECURSIVELY FOR FIBON(N-1) AND FIBON(N-2))
|...
|2^19 BY THE TIME FIBON(20-18) 
|IS 2 ^ (N -1) SO IT GET'S VERY EXPENSIVE VERY RAPIDLY FOR VALUES OF N, THAT'S WHY N=5 IS SO FAST AND N=20 TAKES SO LONG, N = 21 WOULD TAKE TWICE AS MUCH 'STEPS' AS N = 20
|=> VERY EXPENSIVE
MAIN:	HIA.w	R0,-1
	BST	R0
	HIA	R8,R9
	BST	R0
	AFT.w	R9,1	|	LOCAL G ON STACK
	LEZ
	BIG	R0,2(R8)
|RESULT:
	HIA.w	R1,0
	BST	R1
|PARAMS:		
	BST	R0	|	FIBON N
|FUNC:
	BST	R8
	HIA	R8,R9
	SBR	FIBON
	HST	R8
|CLEAR PARAMS:
	OPT.w	R9,1
|GET RESULT:
	HST	R0	|	NEXT VALUE ON STACK SHOULD BE RESULT SO GET IT, HST R0
	DRU
	STP
FIBON:	HIA	R1,1(R8)	|	PARAM N TO R1
	VGL.w	R1,0
	VSP	GEL,IF1Body
	VGL.w	R1,1
	VSP	NGEL,elseIF1
IF1Body:	HIA.w	R0,1
	SPR	eIF1
elseIF1:	BST	R1	|	SAVE THE ORIGINAL N VALUE ON STACK FOR FIBON(N-1)
|RESULT:
	HIA.w	R0,0
	BST	R0
|PARAMS:	
	AFT.w	R1,1	
	BST	R1	|	FIBON N
|FUNC:
	BST	R8
	HIA	R8,R9
	SBR	FIBON
	HST	R8
|CLEAR PARAMS:
	OPT.w	R9,1
|GET RESULT:
	HST	R0
|END FUNCTION FIBON(N-1)
	HST	R1	|	RESTORE THE ORIGINAL N VALUE	FOR FIBON(N-2)
	BST	R0	|	SAVE THE RESULT OF FIBON(N-1)
|RESULT:
	HIA.w	R0,0
	BST	R0
|PARAMS:
	AFT.w	R1,2
	BST	R1
|FUNC:
	BST	R8
	HIA	R8,R9
	SBR	FIBON
	HST	R8
|CLEAR PARAMS:
	OPT.w	R9,1
|GET RESULT:
	HST	R0	|	R0 SHOULD NOW HOLD THE RESULT OF FIBON(N-2)
|END FUNCTION FIBON(N-2)
	HST	R1	|	I DON'T NEED THE ORIGINAL VALUE N ANYMORE SO I RESTORE THE RESULT FROM FIBON(N-1) IN R1
	OPT	R0,R1	|	FIBON(N-1) + FIBON(N-2)
eIF1:	BIG	R0,2(R8)	|	THIS SAVE THE RESULT FROM R0 IN STACK ADDRESS FOR THE RESULT
	KTG
	EINDPR
